#+TITLE: Functions
#+AUTHOR:
#+EMAIL:
#+DATE:
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS: H:2 toc:nil ':nil
#+BEAMER_FRAME_LEVEL: 2
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [smaller, aspectratio=1610]
#+LaTeX_HEADER: \setbeamertemplate{navigation symbols}{}
#+LaTeX_HEADER: \usepackage{verbatim, multicol, tabularx}
#+LaTeX_HEADER: \usepackage{sourcecodepro}
#+LaTeX_HEADER: \usepackage[T1]{fontenc}
#+LaTeX_HEADER: \usepackage{amsmath,amsthm, amssymb, latexsym, listings, qtree}
#+LaTeX_HEADER: \lstset{extendedchars=\true, inputencoding=utf8, frame=tb, aboveskip=1mm, belowskip=0mm, showstringspaces=false, columns=fixed, basicstyle={\footnotesize\ttfamily}, numbers=left, frame=single, breaklines=true, breakatwhitespace=true, tabsize=4,  keywordstyle=\color{blue}, identifierstyle=\color{violet}, stringstyle=\color{teal}, commentstyle=\color{darkgray}, upquote=false, literate={'}{\textquotesingle}1}
#+LaTeX_HEADER: \setbeamertemplate{footline}[frame number]
#+LaTeX_HEADER: \hypersetup{colorlinks=true,urlcolor=blue,bookmarks=true}
#+LaTeX_HEADER: \setlength{\parskip}{.25\baselineskip}
# #+LaTeX_HEADER: \logo{\includegraphics[height=.75cm]{GeorgiaTechLogo-black-gold.png}}

* Functions

** Functions

A function is a reusable block of code. Functions

- have names (usually),
- contain a sequence of statements, and
- return values, either explicitly or implicitly.

We've already used several built-in functions. Today we will learn how to define our own.

** Hello, Functions!

We define a function using the def keyword:

#+begin_src python
>>> def greet():
...     print('Hello')
...
#+end_src

(blank line tells Python shell you're finished defining the function)

Once the function is defined, you can call it:

#+begin_src python
>>> greet()
Hello
#+end_src

*** Active Review

- What happens if you evaluate ~greet~ (without the ~()~) in the Python REPL?

** Defining Functions

The general form of a function definition is

#+begin_src python
def <function_name>(<parameter_list>):
    <function_body>
#+end_src

- The first line is called the header.
- ~function_name~ is the name you use to call the function.
- ~parameter_list~ is a list of parameters to the function, which may be empty.
- ~function_body~ (also called a suite in Python) is a sequence of expressions and statements.

** Function Parameters

Provide a list of parameter names inside the parentheses of the function header, which creates local variables in the function.

#+begin_src python
>>> def greet(name):
        g = "Hello, " + name + "!"
...     print(g)
...
#+end_src

Then call the function by passing *arguments* to the function: values that are bound to parameter names.

Here we pass the value ~'Dolly'~, which is bound to ~greet~'s parameter ~name~ and printed to the console by the code inside ~greet~.

#+begin_src python
>>> greet('Dolly')
Hello, Dolly!
#+end_src

** Function Call Semantics

***                                                                                               :BMCOL:B_block:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :BEAMER_env: block
    :END:

#+begin_src python
>>> g = "Dolly"
#+end_src

Creates a global value[fn:1].

#+name: dolly
#+begin_src ditaa :cmdline --no-separation :file diagrams/dolly.png
+-------------------------------+
|global scope                   |
|                addr1          |
|           +-----+-------+     |
|  +-----+  | str |       |     |
| g|addr1+->+-----+       |     |
|  +-----+  |    Dolly    |     |
|           +-------------+     |
+-------------------------------+
#+end_src

#+ATTR_LATEX: :width 1.75in
#+RESULTS: dolly
[[file:diagrams/dolly.png]]

- Is ~g~ a good variable name here?

[fn:1] Since ~str~ is a sequence data structure, this memory image is a slight simplification.

***                                                                                               :BMCOL:B_block:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :BEAMER_env: block
    :BEAMER_envargs: <2->
    :END:

#+begin_src python
>>> greet(g)
#+end_src

Passes argument ~g~ /by value/, that is, the object pointer in ~g~ is copied to ~greet~'s ~name~ parameter.

#+name: greet-dolly
#+begin_src ditaa :cmdline --no-separation :file diagrams/greet-dolly.png
+-------------------------------+
|global scope                   |
|                addr1          |
|           +-----+-------+     |
|  +-----+  | str |       |     |
| g|addr1+->+-----+       |     |
|  +-----+  |    Dolly    |     |
|           +-------------+     |
|                  ^            |
|                  |            |
|                  |            |
| +----------------|----------+ |
| |greet scope     |          | |
| |                |          | |
| |     +-----+    |          | |
| | name|addr1+----/          | |
| |     +-----+               | |
| +---------------------------+ |
+-------------------------------+
#+end_src

#+ATTR_LATEX: :width 1.75in
#+RESULTS: greet-dolly
[[file:diagrams/greet-dolly.png]]


***                                                                                               :BMCOL:B_block:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :BEAMER_env: block
    :BEAMER_envargs: <3->
    :END:


#+ATTR_LATEX: :options basicstyle=\ttfamily\scriptsize, numbers=left
#+begin_src python
def greet(name):
    g = "Hello, "+name+"!"
    print(g)
#+end_src

Notice that ~greet~'s ~g~ shadows the global ~g~.
#+name: greet-scope
#+begin_src ditaa :cmdline --no-separation :file diagrams/greet-scope.png
+-----------------------------------+
|global scope                       |
|                  addr1            |
|             +-----+-------+       |
|    +-----+  | str |       |       |
|   g|addr1+->+-----+       |       |
|    +-----+  |    Dolly    |       |
|             +-------------+       |
|                    ^              |
|                    |              |
|                    |              |
|   +----------------|----------+   |
|   |greet scope     |          |   |
|   |                |          |   |
|   |     +-----+    |          |   |
|   | name|addr1+----/          |   |
|   |     +-----+               |   |
|   |                addr3      |   |
|   |           +-----+-------+ |   |
|   |  +-----+  | str |       | |   |
|   | g|addr2+->+-----+       | |   |
|   |  +-----+  |Hello, Dolly!| |   |
|   |           +-------------+ |   |
|   +---------------------------+   |
+-----------------------------------+
#+end_src

#+ATTR_LATEX: :width 1.75in
#+RESULTS: greet-scope
[[file:diagrams/greet-scope.png]]


** Strict Argument Evaluation

Arguments to functions are evaluated strictly, meaning that they are evaluated before control is transferred to the function body.

***                                                                                               :BMCOL:B_block:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :BEAMER_env: block
    :END:

#+begin_src python
>>> greet('again')
Guten Tag!
#+end_src

This creates a temporary ~str~ object pointing to the ~Sequence~ value ~'again'~

#+name: again
#+begin_src ditaa :cmdline --no-separation :file diagrams/again.png
+-------------------------------+
|global scope                   |
|                addr5          |
|           +-----+-------+     |
|           | str |       |     |
|           +-----+       |     |
|           |    again    |     |
|           +-------------+     |
+-------------------------------+
#+end_src

#+ATTR_LATEX: :width 1.75in
#+RESULTS: again
[[file:diagrams/again.png]]

***                                                                                               :BMCOL:B_block:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :BEAMER_env: block
    :BEAMER_envargs: <2->
    :END:

and passes a reference to that object to the function.

#+name: greet-again
#+begin_src ditaa :cmdline --no-separation :file diagrams/greet-again.png
+-------------------------------+
|global scope                   |
|                addr5          |
|           +-----+-------+     |
|           | str |       |     |
|           +-----+       |     |
|           |    Dolly    |     |
|           +-------------+     |
|                  ^            |
|                  |            |
|                  |            |
| +----------------|----------+ |
| |greet scope     |          | |
| |                |          | |
| |     +-----+    |          | |
| | name|addr5+----/          | |
| |     +-----+               | |
| +---------------------------+ |
+-------------------------------+
#+end_src

#+ATTR_LATEX: :width 1.75in
#+RESULTS: greet-again
[[file:diagrams/greet-again.png]]


***                                                                                               :BMCOL:B_block:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :BEAMER_env: block
    :BEAMER_envargs: <3->
    :END:


#+ATTR_LATEX: :options basicstyle=\ttfamily\scriptsize, numbers=left
#+begin_src python
def greet(name):
    g = "Hello, "+name+"!"
    print(g)
#+end_src

Then, as before, the local ~g~ object is created.

#+name: greet-again-scope
#+begin_src ditaa :cmdline --no-separation :file diagrams/greet-again-scope.png
+-----------------------------------+
|global scope                       |
|                  addr5            |
|             +-----+-------+       |
|             | str |       |       |
|             +-----+       |       |
|             |    Dolly    |       |
|             +-------------+       |
|                    ^              |
|                    |              |
|                    |              |
|   +----------------|----------+   |
|   |greet scope     |          |   |
|   |                |          |   |
|   |     +-----+    |          |   |
|   | name|addr5+----/          |   |
|   |     +-----+               |   |
|   |                addr6           |   |
|   |           +-----+-------+ |   |
|   |  +-----+  | str |       | |   |
|   | g|addr5+->+-----+       | |   |
|   |  +-----+  |Hello, Dolly!| |   |
|   |           +-------------+ |   |
|   +---------------------------+   |
+-----------------------------------+
#+end_src

#+ATTR_LATEX: :width 1.75in
#+RESULTS: greet-again-scope
[[file:diagrams/greet-again-scope.png]]



** Variable Scope

Parameters are local variables. They are not visible outside the function:

#+begin_src python
>>> name
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'name' is not defined
#+end_src

Global variables are visible outside the function and inside the function.

#+begin_src python
>>> global_hello = 'Bonjour'
>>> global_hello
'Bonjour'
>>> def say_global_hello():
...     print(global_hello)
...
>>> say_global_hello()
Bonjour
#+end_src

** Shadowing Global Variables

Local variables shadow global variables.

#+begin_src python
>>> x = 1
>>> def f():
...     x = 2
...     print("local x:", x)
...     print("global x:", globals()["x"])
...
>>> f()
local x: 2
global x: 1
#+end_src

- Tip: evaluate ~globals()["__name__"]~ in the Python REPL.

A function parameter is a local variable.

#+begin_src python
>>> name = 'Hi ya!'
>>> def greet(name):
...     print(name)
...
>>> name
'Hi ya!'
>>> greet('Hello')
Hello
#+end_src

** Namespaces

Every place where a variable can be defined is called a *namespace* or a *frame* (sometimes also called a *symbol table*, which is how namespaces are implemented by compilers and interpreters).

- Top level, or *global* names (either the Python REPL or a script) are in a namespace called ~__main__~.
- Each function *call* also gets a namespace for the local variables in the function.
- These namespaces are hierarchical -- name resolution starts with the innermost namespace, which is why local variables "hide" or "shadow" global variables.

** Redefining Names

A function a kind of variable. If you define a function with the same name as a variable, it re-binds the name, and vice-versa.

#+begin_src python
>>> global_hello = 'Bonjour'
>>> def global_hello():
...     print('This is the global_hello() function.')
...
>>> global_hello
<function global_hello at 0x10063b620>
#+end_src

** Muliple Parameters

A function can take any number of parameters.

#+begin_src python
>>> def greet(greeting, name):
...     print(greeting + ', ' + name)
...
>>> greet('Greetings', 'Professor Falken')
Greetings, Professor Falken
#+end_src

Parameters can be of multiple types.

#+begin_src python
>>> def greet(name, name, number):
...     print(name * number + ', ' + name)
...
>>> greet('Professor Falken', 'Greetings', 2)
GreetingsGreetings, Professor Falken
#+end_src

** Positional and Keyword Arguments

Thus far we've called functions using positional arguments, meaning that argument values are bound to parameters in the order in which they appear in the call.

#+begin_src python
>>> def greet(greeting, name, number):
...     print((greeting + ', ' + name) * 2)
...
>>> greet('Professor Falken', 'Greetings', 2)
#+end_src

We can also call functions with keyword arguments in any order.

#+begin_src python
>>> greet(greeting='Hello', number=2, name='Dolly')
Hello, DollyHello, Dolly
#+end_src

If you call a function with both positional and keyword arguments, the positional ones must come first.

** Default Parameter Values

You can specify default parameter values so that you don't have to provide an argument.

#+begin_src python
>>> def greet(greeting, name='Elmo'):
...     print(greeting + ', ' + name)
...
>>> greet('Hello')
Hello, Elmo
#+end_src

If you provide an argument for a parameter with a default value, the parameter takes the argument value passed in the call instead of the default value.

#+begin_src python
>>> greet('Hi', 'Guy')
Hi, Guy
#+end_src

** Return Values

Functions return values.

#+begin_src python
>>> def double(num):
...     return num * 2
...
>>> double(2)
4
#+end_src

If you don't explicitly return a value, ~None~ is returned implicitly.

#+begin_src python
>>> def g():
...     print("man") # This is not a return!
...
>>> fbi = g()
man # This is a side-effect of calling g(), not a return value
>>> type(fbi)
<class 'NoneType'>
#+end_src

Function calls are expressions like any other, that is, a function call has a value, so a function call can appear anywhere a value can appear.

#+begin_src python
>>> double(2) + double(3)
10
#+end_src


** Variable Argument Lists

You can collect a variable number of positional arguments as a tuple by preprending a parameter name with ~*~

#+begin_src python
>>> def echo(*args):
...     print(args)
...
>>> echo(1, 'fish', 2, 'fish')
(1, 'fish', 2, 'fish')
#+end_src

You can collect variable keyword arguments as a dictionary with ~**~

#+begin_src python
>>> def print_dict(**kwargs):
...     print(kwargs)
...
>>> print_dict(a=1, steak='sauce')
{'a': 1, 'steak': 'sauce'}
#+end_src

** Mixed Argument Lists

And you can do positional and keyword variable arguments together, but the keword arguments come second.

#+begin_src python
>>> def print_stuff(*args, **kwargs):
...     print(args, kwargs)
...
>>> print_stuff("Pass", "the", a=1, steak='sauce')
{'a': 1, 'steak': 'sauce'}
#+end_src

*** Active Review

- What happens when you evaluate

  #+begin_src Python
  print_stuff("Pass", a=1, steak='sauce', 'the')
  #+end_src

** Inner Functions

Information hiding is a general principle of software engineering. If you only need a function in one place, inside another function, you can declare it inside that function so that it is visible only in that function.

#+begin_src python
def factorial(n):
   def fac_iter(n, accum):
       if n <= 1:
           return accum
       return fac_iter(n - 1, n * accum)
   return fac_iter(n, 1)

>>> factorial(5)
120
#+end_src

~fac_iter()~ is a (tail) recursive function. Recursion is important for computer scientists, but a practically-oriented Python-programming engineer will mostly use iteration, higher-order functions and loops, which are more [[http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html][Pythonic]]. Any recursive computation can be formulated as an imperative computation.

*** Active Review

- Define the ~factorial~ function above in your REPL and evaluate the following calls:

  #+begin_src Python
  factorial(10)
  factorial(100)
  factorial(1000)
  factorial(10000)
  #+end_src

** Conclusion

- Functions are the primary way we break a program into reusable pieces.
- Use functions liberally.
