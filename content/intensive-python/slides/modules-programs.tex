% Created 2022-08-15 Mon 19:07
% Intended LaTeX compiler: pdflatex
\documentclass[smaller, aspectratio=1610]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\setbeamertemplate{navigation symbols}{}
\usepackage{verbatim, multicol, tabularx}
\usepackage{sourcecodepro}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsthm, amssymb, latexsym, listings, qtree}
\lstset{extendedchars=\true, inputencoding=utf8, frame=tb, aboveskip=1mm, belowskip=0mm, showstringspaces=false, columns=fixed, basicstyle={\footnotesize\ttfamily}, numbers=left, frame=single, breaklines=true, breakatwhitespace=true, tabsize=4,  keywordstyle=\color{blue}, identifierstyle=\color{violet}, stringstyle=\color{teal}, commentstyle=\color{darkgray}}
\setbeamertemplate{footline}[frame number]
\hypersetup{colorlinks=true,urlcolor=blue,bookmarks=true}
\setlength{\parskip}{.25\baselineskip}
\usetheme{default}
\date{}
\title{Modules and Programs}
\hypersetup{
 pdfauthor={},
 pdftitle={Modules and Programs},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.1 (Org mode 9.5.2)},
 pdflang={English}}
\begin{document}

\maketitle

\section{Modules and Programs}
\label{sec:org35365e3}

\begin{frame}[label={sec:org2183131}]{Python Programs}
Python code organized in

\begin{itemize}
\item modules,
\item packages, and
\item scripts.
\end{itemize}

We've already used some modules, now we'll learn what they are, how they're orgainized in packages, and how to write Python programs that can be run on their own, not just entered in the Python command shell.
\end{frame}

\begin{frame}[label={sec:org8eb6f8b},fragile]{Importing Modules}
 To \texttt{import} a module means to get names from the module into scope, or add them to a namespace. When you import a module, you can access the module's members with the dot operator.

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
>>> import math   # Adds the math module to the current namespace
>>> math.sqrt(64) # Uses the sqrt function from the math module
8.0
\end{lstlisting}

You can  also import a module and give it an alias: \texttt{import <module> as <local-name>}

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
>>> import math as m
>>> m.sqrt(64)
8.0
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgb9b9e5d},fragile]{Importing into Local Scope}
 Importing brings names into the scope of the import.  Here we import the math module into the scope of a single function:

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
>>> def hypotenuse(a, b):
...     import math
...     return math.sqrt(a*a + b*b)
...
>>> hypotenuse(3, 4)
5.0
\end{lstlisting}

But it's not available at the top level.

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
>>> math.sqrt(64)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name 'math' is not defined
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org5623832},fragile]{Importing Names from a Module}
 You can choose to import only certain names from a module:

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
>>> from math import sqrt
>>> sqrt(64)
8.0
>>> floor(1.2)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name 'floor' is not defined
\end{lstlisting}

Or all names from a module:

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
>>> from math import *
>>> floor(1.2)
1
>>> sin(0)
0.0
>>> sin(.5 * pi)
1.0
\end{lstlisting}

Using this syntax adds the names from the module to your namespace so that you don't have to use a fully-qualified name, e.g., you can say \texttt{sqrt(64)} instead of \texttt{math.sqrt(64)}.
\end{frame}


\begin{frame}[label={sec:orgd4aeca5},fragile]{Namespace Pollution}
 It's usually better to import modules and access their members with dot notation.  When you \texttt{import ... from ..} from several modules, especially if you use \texttt{*}, you "pollute" your namespace with many names and potentially cause problems.

\begin{block}{Active Review}
Evaluate the following, in order, in a Python REPL:

\begin{itemize}
\item \texttt{from logging import *}
\item \texttt{log(WARN, 'A log message')}
\item \texttt{from math import *}
\item \texttt{log(WARN, 'A log message')}
\end{itemize}

What happened?
\end{block}
\end{frame}

\begin{frame}[label={sec:org699ffa0},fragile]{Writing Python Modules}
 A Python module is text file ending in \texttt{.py} -- this is why you should always name your Python source files with a \texttt{.py} ending.  A module typically includes classes, functions and variables.

\begin{block}{Active Review}
Save the following code in a file named \texttt{arithmetic.py}:

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
  def add(a: int, b: int) -> int:
      return a + b

  def sub(a: int, b: int) -> int:
      return a - b

  def mul(a: int, b: int) -> int:
      return a * b

  def div(a: int, b: int) -> int:
      return a / b
\end{lstlisting}

\begin{itemize}
\item In your Python REPL, evaluate \texttt{import arithemtic}.
\begin{itemize}
\item Did you get an error?  What caused the error?
\end{itemize}
\item If you got an error when you tried to import your \texttt{arithmetic} module, fix it.
\item Now use functions from your \texttt{arithmetic} module to make sure it works.
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[label={sec:org212e087},fragile]{Python Scripts}
 A Python script is any text file containing executable Python code.  Our \texttt{hello.py} script from Day 1 is an example of a Python script.  Note that a module can be a Python script if it contains code that executes whenever the module is run by the Python interpreter.

\begin{block}{Active Review}
\begin{itemize}
\item Run \texttt{arithmetic.py} in "script mode" by entering \texttt{python3 arithmetic.py} in your OS command shell.
\begin{itemize}
\item What happened?
\end{itemize}
\item Add the following to the bottom of your \texttt{arithmetic.py} file:

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
  import sys
  ops = {'+': add, '-': sub, '*': mult, '/': div}
  op = ops[sys.argv[2]]
  print(op(int(sys.arg[1]), int(sys.arg[2])))
\end{lstlisting}

\item Run \texttt{arithmetic.py} with \texttt{python3 arithmetic.py 6 + 2}.
\item Restart your Python REPL and import your \texttt{arithmetic} module.
\begin{itemize}
\item What happened?
\end{itemize}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[label={sec:org4a67a63},fragile]{\texttt{if \_\_name\_\_ == '\_\_main\_\_'}}
 To make a module a script that only evaluates definitions when imported and only runs the "script" parts when run by the Python interpreter, include an \texttt{if \_\_name\_\_ == '\_\_main\_\_'} block at the bottom.  The code in the \texttt{if \_\_name\_\_ == '\_\_main\_\_'} block will only execute when the module is run as a script.

\begin{block}{Active Review}
Add the following to the bottom of your \texttt{arithmetic.py} module:

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if __name__ == '__main__':
    import sys
    ops = {'+': add, '-': sub, '*': mult, '/': div}
    op = ops[sys.argv[2]]
    print(op(int(sys.arg[1]), int(sys.arg[2])))
\end{lstlisting}

\begin{itemize}
\item Run \texttt{arithmetic.py} in "script mode" with \texttt{python3 arithmetic.py}.
\begin{itemize}
\item What happened?
\end{itemize}
\item Run \texttt{arithmetic.py} with \texttt{python3 arithmetic.py 6 + 2}.
\item Run \texttt{arithmetic.py} with \texttt{python3 arithmetic.py 6 / 2}.
\item Run \texttt{arithmetic.py} with \texttt{python3 arithmetic.py 6 * 2}.
\begin{itemize}
\item What happened?
\end{itemize}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[label={sec:orgc324f2b},fragile]{Shebang!}
 Another way to run a Python program (on Unix) is to tell the host operating system how to run it. We do that with a "shebang" line at the beginning of a Python program:

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#!/usr/bin/env python3
\end{lstlisting}

This line says "run python3 and pass this file as an argument." So if you have a script in \texttt{foo.py} with shebang line as above and which has been set executable (\texttt{chmod +x foo.py}), these are equivalent:

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
$ python3 foo.py
$ ./foo.py
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgb75c8b5},fragile]{Command-line Arguments}
 When you run a Python program, Python collects the arguments to the program in a variable called sys.argv. Given a Python program (\texttt{arguments.py}):

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#!/usr/bin/env python3
import sys

print(sys.argv)

if len(sys.argv) < 2:
    print("You've given me nothing to work with.")
else:
    print(sys.argv[1] +"? Well I disagree!")
\end{lstlisting}

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
$ ./arguments.py Pickles
Pickles? Well I disagree!
$ ./arguments.py
You've given me nothing to work with.
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org64dc221},fragile]{Interactive Programs}
 The input() function Python reads all the characters typed into the console until the user presses ENTER and returns them as a string:

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
>>> x = input()
abcdefg1234567
>>> x
'abcdefg1234567'
\end{lstlisting}

We can also supply a prompt for the user:

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
>>> input('Give me a number: ')
Give me a number: 3
'3'
\end{lstlisting}

And remember, input() returns a string that may need to be converted.

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
>>> 2 * int(input("Give me a number and I'll double it: "))
Give me a number and I'll double it: 3
6
\end{lstlisting}
\end{frame}


\begin{frame}[label={sec:org509296d},fragile]{Module Search Path}
 Just as an operating system command shell searches for executable programs by searching the directories listed in the \texttt{PATH} environment variable, Python finds modules by searching directories. The module search path is stored in \texttt{sys.path}:

\lstset{language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
>>> import sys
>>> from pprint import pprint
>>> pprint(sys.path)
['',
 '/usr/lib/python38.zip',
 '/usr/lib/python3.8',
 '/usr/lib/python3.8/lib-dynload',
 '/home/chris/.local/lib/python3.8/site-packages',
 '/usr/local/lib/python3.8/dist-packages',
 '/usr/lib/python3/dist-packages']
\end{lstlisting}

Notice that the current directory, represented by the \texttt{''} at the beginning of the search path, is part of \texttt{sys.path}, which is why you can import modules located in your current directory.

Also, note use of \texttt{pprint}.
\end{frame}

\begin{frame}[label={sec:orgf2822db}]{Conclusion}
\begin{itemize}
\item Be careful to distinguish between a Python RELP prompt, and an OS command shell prompt.
\end{itemize}

\begin{center}
\includegraphics[height=.4\textheight]{./Argument_Clinic.png}
\end{center}


\href{https://www.youtube.com/watch?v=DkQhK8O9Jik}{Arguments}
\end{frame}
\end{document}